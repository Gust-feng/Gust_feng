#你刚得知新购买的餐桌无法及时送达，因此只能邀请两位嘉宾。·以完成练习3-6时编写的程序为基础，在程序末尾添加一行代码，打印一条你只能邀请两位嘉宾共进晚餐的消息。·使用pop()不断地删除名单中的嘉宾，直到只有两位嘉宾为止。每次从名单中弹出一位嘉宾时，都打印一条消息，让该嘉宾知悉你很抱歉，无法邀请他来共进晚餐。·对于余下的两位嘉宾中的每一位，都打印一条消息，指出他依然在受邀人之列。·使用del将最后两位嘉宾从名单中删除，让名单变成空的。打印该名单，核实程序结束时名单确实是空的。
list_name=['候一簇花开','超越','晚来怀海棠']
print(f'我想和{",".join(list_name)}一起共进晚餐')
list_name_del=list_name.pop(1)
list2_name="怎会这么狼狈"
list_name.insert(1,list2_name)
print(f'但{list_name_del}无法赴约，所以我重兴邀请了{list2_name}')
print(f'我又重新邀请了{",".join(list_name)}参加晚餐')    
#这里我想使用列表添加元素，而不是一一添加的方式
#但至于元素名称的选择着实令我头疼，故采用一以贯之的取名方法
list_app=['小明','小红']
list_name.append(",".join(list_app))
print(f'在邀请人数增加后，我决定邀请{",".join(list_name)}参加晚宴')
print(f'对了，我还疏忽了一个人，@小刚')#为使用insert()进行扩写
list_name.insert(0,"小刚")
print(f'所以最后邀请的名单是：\n{list_name}')
print(f'可遗憾的是突然得知我并不能邀请这么多人参加了，我只能邀请两位\n斟酌良久我决定邀请{list_name[1]}和{list_name[3]}')
#pop_list=[0,2,4,5]，重新编写
'''
for i in pop_list:
    n=list_name.pop(i)
    print(f'很遗憾，因为某些原因无法宴请您参加晚宴，望你见谅@{n}')
'''
#之所以把上面代码注释掉是因为存在一个细节错误
#我将娓娓道来
#在这里我的想法是通过for语句循环pop_list中的数值达到删除list_name中的元素，但是！在for遍历的过程中它是动态过程，也是说在for循环删除元素时，处理的列表的是一个不断减少的列表
#看不懂没关系，现在有个印象就好
#现在重新处理
pop_list=list_name[:]
for i in pop_list:
    if i !='晚来怀海棠' and i !='候一簇花开':
        print(f'很遗憾，由于某些特殊原因无法宴请您参加晚宴，望你见谅@{i}')
    else:
        print(f'很期待你的到来\n\t@{i}')#这里我还想对结果进行排序，解决输出杂乱的问题。不过算了，懒得优化。如果需要改进的话，可以创建两个空列表，将输出结果append空列表。
#这代码又困扰我一段时间，至于为什么呢？难说
#代码旨在分类打印不同情况
#对代码具体解释：如果i不等于'晚来怀海棠'和'候一簇花开'那么条件为真，运行if语句
#---存在一问题点，就是不理解i是代表什么，具体为对'and'的理解。在if语句中i是一个变量，通过比较这个变量的值来判断if语句是否成立。再进一步说就是i和'and'两边条件比较。但其核心在于if语句真假判断
#看不懂请 访问='../解惑/if 语句添加理解.py'
'''for n in pop_list:
    del pop_list[n]
    '''#之所以注释这段代码是因为list[]中的值应该为一个整数，但在for中是字符串，当然运行结果也必报错
while pop_list:
    del pop_list[0]
print(f'根据最后的要求，我应该删除所有嘉宾，最后的结果是\n\t{pop_list}')
print(f'但是我并不想如此，我还是想邀请{",".join(list_name[i] for i in [1,3])}')